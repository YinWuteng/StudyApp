1.哪种情况下的对象会被垃圾回收机制处理掉
  New出来的对象不再被引用。
  延伸： 垃圾回收机制是java语言拥有一套完整的垃圾回收机制。原理是java周期性的检测某个实体是否不再被任何对象所引用，若发现这样的实体，就是释放实体的内存。
  可达性分析算法
2.常见的编码方式
  ASCII码，ISO-8859-1，GBK GB18030 UTF-16 UTF-8
3.utf-8编码中的中文占几个字节，int型几个字节
  中文3个字节。
4.静态代理和动态代理的区别，什么场景使用？
  静态代理：由程序员创建或工具生成代理类的源码，在编译代理类，所以静态也就在程序运行前就已经存在代理的字节码文件，代理类和为委托类的关系在运行前就确定了。
  动态代理：在程序运行时运用反射机制动态创建而成。
5.Java的异常体系
  异常机制。是指程序不正常时的处理方式。具体来说，异常机制提供了程序退出的安全通道。当出现错误后。程序执行的流程发生改变，程序的控制权转移到异常处理器。
  除非你能解决这个异常，否则不要捕获他，如果打算记录消息错误，那么别忘了最后将异常抛出，异常既代表一种错误，又可以代表一个消息。
6.对java反射的理解
  在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法。对于任何一个对象，都能给调用它的任意一个方法和属性，这种动态获取对象信息、动态调用对象的方法的功能称为JAVA语言的反射机制。经典的就是在xml文件或者properties里面写好了配置，然后在Java类里面解析xml或properties里面的内容，得到一个字符串，然后用反射机制，根据这个字符串获得某个类的Class实例，这样就可以动态配置一些东西，不用每一次都要在代码里面去new或者做其他的事情，以后要改的话直接改配置文件，代码维护起来就很方便了，同时有时候要适应某些需求，Java类里面不一定能直接调用另外的方法，这时候也可以通过反射机制来实现。
7.Java的四种注解
  1.@Target 表示该注解可以用来干什么地方，可能对于ElementType参数包括CONSTRUCTOR：构造器的声明
   FIELED：域声明(包括enum实例)
   LOCAL_VARIABLE:局部变量声明
   METHOD:方法声明
   PACKAGE:包声明
   PARAMETER：参数声明
   TYPE:类、接口声明
  2.@Retention 表示需要在什么级别保存该注解信息，可选类型：
   SOURCE:注解将被编译器丢弃
   CLASS:注解在class文件中可用，但会被VM丢弃
   RUNTIME：VM将在运行期也保留注解，因此可以通过反射机制读取注解。
  3.@Document 此注解包含在javadoc中
  4.@Inherited  允许子类集成父类中的注解
8.Java注解的理解
  对程序代码本身的描述，代码原数据，一种约定的规范。包括格式、意义、作用域等。
  注解对象：注解可以被用在包、类、方法、变量、参数上；
  注解不会直接影响被注解的代码。这只会向第三系统提供关于自己的信息已用于不同的需求
  注解会被编译至class文件中，而且会在运行时被处理程序提取出来用于业务处理。当然，创建在运行时不可用的注解也是可能的，甚至可以创建只在源文件中可用，在编译时不可用的注解。
9.说说你对依赖注入的理解
  依赖注入就是把本来应该在程序中有的依赖在外部注入到程序中，也是设计模式的一种思想。
10.说一下泛型原理，并举例说明
  泛型是为了避免类转换异常的发生，使程序操作更安全。