kotlin语言基础
1.var是可写的，在它生命周期中可以被多次赋值
2.val是只读的，仅能一次赋值，后面就不能被重新赋值了
流程控制语句
分支语句：if when
循环语句：for while
跳转语句：break,continue,return,throw

安全调用(?.),当为空指针时，不会抛出异常，
非空断言调用(!!.) 当为空指针时，会抛出异常

kotlin是一门强类型的、静态类型、支持隐式类型的显示类型语言。
字符串模板,模板表达式以美元($)开头
var h=10
var str="A hundred is $h"
A hundred is $h
kotlin允许不同类型的元素放到一个数组中 arrayOf(1,2,"a")

is运算符可以检查对象是否与特定的类型兼容，用来检查对象是否属于某数据类型
as运算符用于执行引用类型的显示类型转换

集合类存放的都是对象的引用，而非对象本身，我们通常说的集合中的对象指的是集合中对象的引用。
kotlin中的List分为两种:不可变集合类List(Immutable)和可变集合类MutableList.
kotlin中的Set分为两种：不可变Set和可变Set(MutableSet)
kotlin中的Map分为两种：不可变Map和可变Map(MutableMap)

kotlin中，我们把只能保证读取数据时类型安全的对象叫做生产者，用out T(等价于extend T)标记
          把只能保证写入数据安全时类型安全的对象叫消费者 用in T(等价于 super T)标记

kotlin构造函数
constructor,主构造函数是类头的一部分，直接放在类名后面，主构造函数不能包含任何代码，初始化的代码可以放到
以init关键字作为前缀的初始化块中
次构造函数不能有声明var或val
如果一个类有主构造函数，那么每个次构造函数需要委托给主构造函数，委托到同一个类的另一个构造函数用this关键字即可

抽象类中的抽象函数可以被子类重写，实现类函数不能被重写，因为默认是final的，若想重写，在函数名前添加open关键字即可
object对象
在java中通常会写一些utils类，这样的类我们在kotlin中就可以直接使用object对象。
伴生对象 companion object
一个类只能有一个伴生对象，我们可以直接像在Java静态类中使用静态方法一样使用一个类的伴生对象的函数和属性
伴生对象的初始化时在相应的类被加载解析时，与Java静态初始化器的语义相匹配

密封类(sealed)
一个类之所以设计成seald，就是为了限制类的继承结构
密封类的主要场景是在使用when表达式的时候，能够验证语句覆盖的所有情况，而无需添加一个else子句。

嵌套类
访问嵌套类的方式是直接使用"类名."，有多少层嵌套，就用多少层类名加点号来访问
嵌套类访问不到上一层类的变量，如果想访问，在该类前面加inner关键词修饰，表明是一个嵌套的内部类。

委托
委托属性赋予了属性富有变化的活力
延迟属性(lazy properties)其值只在首次访问时计算
可观察属性(observable properties):监听器会收到有关此属性变更的通知
把多个属性存储在一个映射map中，而不是每个存在单独的字段中

闭包：闭包就是把函数以及变量包起来，使得变量的生存周期延长

协程提供了一种避免阻塞线程并用更简单、更可控的操作替代线程阻塞的方法：协程挂起
协程可以用来解决很多问题，比如嵌套回调、并发编程模型的实现等。
协程中的代码是默认的顺序执行
协程并不是取代线程，而是抽象于线程之上，线程是被分割的CPU资源，协程是组织好的代码流程。
协程需要线程来承载运行，线程是协程的资源。
协程好处：CPU消耗低，简化了多线程的同步性，摆脱了异步编程的一对callback函数。

使用launch函数启动协程，我们不能使用Thread来启动协程代码
CommonPool是代表共享线程池，它的主要作用是来调度计算密集型任务的协程的执行
runBlocking主要用来桥接普通阻塞代码和挂起风格的非阻塞代码
join用于让协程参加到主线程的时间顺序里，让主线程一直等到当前协程执行完毕再结束
计算代码协程的取消方式
1.显示检查取消状态isActive
2.循环调用一个挂起函数yield()

启动协程的三种方式
lanuch(CommonPool)
async(CommonPool)
run(NoCancellable)

使用无限制的Unconfined上下恩的协程运行在主线程中
继承runBlocking{....}的context的协程继续在主线程中执行
CommonPool在ForkJoinPool.commonPool中
新创建的协程(newSingleThreadContext)，该协程运行在自己的新线程

父子协程
例程被定义为操作的序列，例程的执行形成了父子关系，且孩子例程总是在父例程前结束。协程是例程的泛化概念。
当我们用协程A的上下问启动另一个协程B时，A就是B的父协程，B将成为A的子协程。

通道提供了一种传输数据流的方法，通道是使用SendChannel和使用ReceiveChannel之间的非阻塞通信。通道的概念类似于阻塞队列。
通道与队列不同，通道可以手动关闭

管道是一个允许单向信息传递的数据结构
从管道写入端写入的数据可以从读取端读回。
管道是串行的，从管道中读取的数据总是会保持写入时的顺序。
管道通常用于一个进程中两个线程之间的通信，或用于父子进程之间的通信。

kotlin中let(),with(),run(),applay() also函数的使用方法与区别
这几个方法位于kt源码标准库standard.kt中，kt扩展函数库优化kt的编码
在kt中，对于接口只有一个回调的方法，就符合lambda函数
内联扩展函数let：当你需要去定义一个变量在一个特定的作用域范围内，let函数的是一个不错的选择
let函数另外一个作用就是可以避免写一些null的操作。

内联函数with:将某对象作为函数的参数，在函数块内可以通过this指代该对象，返回值为函数块的最后一行或指定return表达式
经常用于recycleView中onBinderViewHolder中，数据model映射到UI上

内联函数run:run函数实际上可以说是let和with两个函数的结合体。run函数只接收一个lambda函数为参数，以闭包形式返回，
返回值为最后一行或者指定的return表达式
适用于let,with函数任何场景。

内联函数apply:apply和run函数很想，唯一不同的是它们各自返回的值不一样，run函数是以闭包形式返回最后一行代码的值，而apply函数返回的是传入对象的本身
apply一般用于对一个对象实例初始化的时候，需要对对象的属性进行赋值。或者动态inflate出一个xml的View、数据model向View model转化实例化的过程中需要用到

内联函数之also:与let很像，但是返回值不一样，let是以闭包的形式返回，返回函数内最后一行的值，如果最后一行为空就返回一个Unit类型的默认值，
而also返回的则是传入对象的本身
