设计模式六大原则
单一职责：不要存在多余一个导致类变更的原因，一个类只负责一项职责
里氏替换原则：子类可以扩展父类的功能，但不能改变父类原有的功能
依赖倒置原则：高层模块不应该依赖低层模块，二者都应该依赖于抽象，抽象不应该依赖细节，细节应该依赖抽象
              可以降低类之间的耦合，提高系统的稳定性，降低修改程序的风险
接口隔离原则：客户端不应该依赖它不需要的接口，一个雷对另一个类的依赖应该建立在最小的接口上
迪米特原则：一个对象应该对其他对象保持最少的了解
开闭原则：一个软件实体如类、模块、函数应该对扩展开放，对修改关闭


创建型模式：主要关注对象的穿件，讲对象的创建过程中进行封装，使客户端可以直接得到对象，而不用去关心对象的创建。
单例模式 ：确保一个类只有一个实例，而且自行实例化并向整个系统提供这个实例
           优点：避免产生多个对象消耗过多的资源，比如数据库的操作，网络请求。
           缺点：没有抽象层，因此扩展很难，职责过重，在一定程序上违背了单一职责。
工厂方法模式：定义一个用于创建对象的接口，让子类决定实例化哪个类，工厂方法使一个类的实例化
              延迟到其子类，
			  优点：可以使代码结构清晰，有效地封装变化。对调用者屏蔽具体的产品类。降低耦合度。
              简单工厂(静态工厂)三要素：工厂实现、产品接口、产品实现。扩展性比工厂方法稍弱。
			  工厂方法四要素：工厂接口、工厂实现、产品接口、产品实现。
抽象工厂模式：为创建一组相关或相互依赖的对象提供接口，而且无需指定他们的具体类。
工厂方法模式所提供的所有产品都是衍生自同一个接口或抽象类，而抽象工厂模式所提供的产品则是衍生字不同的接口或抽象类。
抽象工厂模式中，有一个产品族的概念，所谓的产品族，是指位于不同产品等级结构中功能相关联的产品组成的家族。
与工厂模式区别：工厂方法模式针对的是一个产品等级结构，而抽象工厂模式则是针对的多个产品等级结构。
最主要的优点是可以在类额内部对产品进行约束，不必专门引入一个新的类来进行管理。
缺点：产品族的扩展是一件十分费力的事情，加入产品族中需要增加一个新的产品，则几乎所有的工厂类都要进行修改。

建造者模式：将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。
四要素：
       产品类：一般为一个较为复杂的对象，也就数说创建对象的过程比较复杂，一般会有较多的代码量
	   抽象建造者：是为了将建造者的具体过程交与它的子类来实现
	   建造者：实现抽象类的所有未实现的方法，组建产品、返回组建好的产品
	   导演类：一般来说，导演类被用来封装程序中易变的部分
建造者模式的封装性很好，使用建造者可以有效的封装变化，建造者很容易进行扩展，如果有新的需求，通过实现一个新的建造者类就可以完成，
建造者模式与工厂模式极为相似，仅仅多了一个导演类。与工厂模式相比，建造者模式一般用来创建更为复杂的对象。

原型模式：用原型实例指定创建对象的种类，并通过拷贝这些原型创建新的对象。
具备以下两个条件：1.实现Cloneable接口，2.重写Object的clone方法。
好处：使用原型模式创建对象比直接new一个对象在性能上要好得多，另一个好处是简化对象的创建。



行为类模式
模板方法模式：定义一个操作中算法的框架，而将一些步骤延迟到子类中，使得子类可以不改变算法的结构即可重定义该算法的某些特定步骤。
模板方法模式由一个抽象类和一个(或一组)实现类通过继承结构组成，抽象类中的方法分为三种：
抽象方法：父类中只声明但不加以实现，而是定义好规范，然后由它的子类去实现
模板方法：由抽象类声明并加以实现，一般来说，模板方法调用抽象方法来完成主要的逻辑功能，并且模板方法大多会定义为final型，指明主要的逻辑功能在子类中不能被重写。
钩子方法：由抽象类声明并加以实现，但是子类可以去扩展，子类可以通过扩展钩子方法来影响模板方法的逻辑。
优点：容易扩展，便于维护，比较灵活，

中介模式：用一个中介者对象封装一系列的对象交互，中介者使各对象不需要显示的相互作用，从而使耦合松散，而且可以独立地改变它们之间的交互。
主要分为三部分：
抽象中介者：定义好同事类对象到中介者对象的接口，用于各个同事类之间的通信。
中介者实现类：从抽象中继承，实现抽象中介者中定义的事件方法。
同事类：如果一个对象会影响其他的对象，同事也会被其他对象影响，那么这两个对象称为同事类。
好处：适当的使用中介模式可以避免类之间的国度耦合，使得同事类之间可以相互独立的使用。

观察者：定义对象间一种一对多的依赖关系，使得当每一个对象改变状态，则所有依赖于它的对象都会得到通知并自动更新。
四个角色：被观察者(Vector线程安全、一般抽象类)，观察者(一般一个接口)，具体的被观察者、具体的观察者。
观察者与被观察者之间属于轻度的关联关系，并且是抽象耦合，这样，对于两者来说都是比较容易进行扩展。
由于观察者的链式触发，当观察者比较多的时候，性能 问题是比较令人担忧的，并且链式结构中，比较容易出现循环引用的错误，造成系统假死。

访问者模式：封装某些作用于数据结构中各元素的操作，它可以在不改变数据结构的前提下定义作用于这些元素的新的操作。

命令模式：将一个请求封装成一个对象，从而让你使用不同的请求把客户端参数化，对请求队列或者记录请求日志，可以提供命令的撤销和恢复功能。
基本结构：
Command类：是一个抽象类，类中对需要执行的命令进行声明，一般来说要对外公布一个execute方法用来执行命令，
ConcreteCommand类：Command类的实现类，对抽象类中声明的方法进行实现，
Client：最总的客户端调用类。
调用者，负责调用命令；接收者，负责接收命令并执行命令。
优点：封装性很好，每个命令都被封装起来；扩展性很好，
缺点：命令很多的话，开发比较繁琐。

责任链模式：使多个对象都有机会处理请求，从而避免了请求的发送者和接收者之间的耦合关系。将这些对象连成一条链，并沿着这条链传递该请求，
            直到有对象处理它为止。
责任链的类图非常简单，它由一个抽象的处理类和它的一组实现类组成。
抽象处理类：抽象处理类主要包含一个指向下一处理类的成员变量nextHandler和一个处理请求的方法handRequest,handRequest方法的主要思想是，如果
            满足处理的条件，则有本处理类来进行处理，否则由nextHandler处理。
责任链模式与if....else相比，耦合性要低一些，缺点：当责任链比较长时，性能问题比较严重。

策略模式：定义一组算法，讲每个算法都封装起来，并且使他们之间可以互换
策略模式与模板方法的区别仅仅是多了一个单独的类Context,模板方法中调用算法的主体在父类，
         而策略模式中调用算法在Context中
 优点：策略类之间可以自由切换，易于扩展
 缺点：维护各个策略类会带来额外开销，策略类较多时，比较麻烦，违背迪米特原则

 迭代器模式：提供一种方法访问一个容器对象中各个元素，而不是暴露该对象的内部细节
 常用的迭代器

 解释器模式：给定一种语言，定义他的文法的一种表示。并定义一种解释器，该解释器使用该表示来解释语言中的句子。

 备忘录模式：在不破坏封装的前提下，捕获一个对象内部状态，并在该对象之外保存这个状态，这样就看讲该对象回复到原先保存的状态。

 适配器模式：将某个类的接口转换成客户端期望的另一个接口的表示，目的是消除接口的不匹配
 主要分为三类：类的适配器模式，对象的适配器模式，接口的适配器模式
 经典案例：ListView,recycleview,grideview,broadcastrReceiver


 结构型
 享元模式：当一个软件系统中运行产生的对象数量太多，将导致运行代价过高，带来系统性能低下，所以需要一个共享来避免大量拥有相同内容对象的开销
          ，String、Message对象就是使用的享元模式
 装饰者模式：动态的给一个对象添加一些额外的职责，是继承的替代方案。装饰模式比生产子类更加灵活
 核心模块：抽象构建、具体构建、抽象装饰类、具体装饰类
 优点：对于扩展一个对象的功能，装饰者模式比继承更加灵活，不会导致类的个数的急剧增加，可以对一个对象进行多次装饰
 缺点：会产生很对小对象，在一定层度上影响程序的性能，比继承更容易出错，调试排查错误较为繁琐。