1.开启线程的三种方式
  继承Thread类创建线程类，实现Runnable接口，通过Callable和Future创建线程。
2.线程和进程的区别
  进程是CPU资源分配的最小单元，线程是CPU调度的最小单位。线程是建立在进程的基础上的一次程序运行单位。
  一个线程可以创建和撤销另一个线程，同一个进程中的多个线程之间可以并发执行。
3.线程的run和start区别
  用start方法来启动线程，真正实现了多线程运行，这时无需等待run方法体现代码执行完毕而直接继续执行下面的代码，start方法来启动线程，run方法执行，执行结束后，此线程随机终止。
  而run方法只是类的一个普通方法，如果直接调用run方法，程序中依然只有主线程这一个线程，其程序执行路径还是只有一条，还是要顺序执行，还是要等待。
  所以实际中往往采用实现runable接口来实现真正的多线程。
4.如何控制某个方法允许并发访问线程的个数
  信号量Semaphore，有时被称为信号灯，时在多线程环境下使用的一种设施，它负责协调各个线程，以保证他们能够正确、合理的使用公共资源。
5.在java中wait和sleep方法的不同
  Sleep是Thread类的方法，导致此线程暂停执行指定时间，给执行机会给其他线程,并不会释放同步资源锁。
  Wait是Object的方法，当一个线程执行到wai方法时，它就进入到一个和该对象相关的等待池中，同时释放了对象的锁。
  Sleep使用是必须捕获异常，而wait不需要捕获异常。
6.谈谈wait/notify关键字的理解
  都属于Object基础类，wait是进行线程等待，而notify是通知等待队列中的第一个相关线程。
7.什么情况会导致线程阻塞
  ①　线程执行了Thread.sleep方法
  ②　线程执行一段同步代码，但是尚且无法获得相关的同步锁，只能进入阻塞状态，
  ③　线程执行了一个对象的wait方法，
  ④　线程执行某些IO操作，因为等待相关的资源而进入了阻塞状态。
8.线程如何关闭
  ①　使用退出标志，使线程正常退出，也就是当run方法完成后线程终止；
  ②　使用stop方法强行终止线程；
  ③　使用interrup方法中断线程。
9.讲一下java中同步的集中方法
  1.同步方法synchronized；
  2.同步代码块synchronized；
  3.特殊域变量 volatile，volatile不能修饰final的变量
  4.使用重入锁ReentrantLock
  5.使用局部变量ThreadLocal实现

  悲观锁：就是很悲观，每次去那数据的时候都认为别人会修改，所以每次在拿数据的时候都会锁。
  传统的关系型数据库里面就用到了很多这种锁机制
  乐观锁(CAS)：就是很乐观，每次去拿数据的时候都认为别人不会修改，所以不会上锁。但是在更新数据时，
  可以使用版本号等机子，乐观锁多用于多读的应用类型，这样可以提高吞吐量。
  乐观锁适用于写比较少的情况。

10.java中对象的生命周期
  1.创建阶段
  2.应用阶段
  3.不可见阶段
  4.不可达阶段
  5.收集阶段
  6.终结阶段
  7.对象空间重分配阶段
11.理解Synchronized
  synchronized是java的关键字，是一种同步锁，它修饰的对象有一下几种：
  1.修饰一个代码块，被修饰的代码块称为同步代码块，起作用的范围是大括号括起来的代码，作用的对象是调用这个代码块的对象。
  2.修饰一个方法，被修饰的方法被称为同步方法，其作用的范围是整个方法，作用的对象是调用这个方法的对象；
  3.修改一个静态的方法，其作用的范围是整个静态方法，作用放入对象是这个类的所有对象；
  4.修饰一个类，区作用的范围是sychronized后面括号括起来的部分，作用的对象是这个类的所有对象。
12.Volatile关键字
   Volatile，它能使变量在值发生改变时能尽快的让其他线程知道。
13.Volatile与synchronized区别
   1.Volatile的本质是在告诉jvm当前变量在寄存器中的值是不确定的，需要从内存中读取，synchronized则是锁定当前变量，只有当前线程可以访问该变量，其他线程被阻塞住；
   2.Volatile仅能使用在变量级别，synchronized则可以使用在变量方法；
   3.Volatile仅能实现变量的修改可见性，synchronized则可以保证变量的修改可见性和原子性；
   4.Volatile不会造成线程的阻塞，而synchronized可能会造成线程的阻塞；

14.synchronized与Lock的区别
  主要相同点：Lock能完成synchronized所实现的所有功能；
  sychronized基于jvm，而lock是java5以后才出来的一个新类。
  不同点：Lock有比synchronized更精确的现场语义和能好的性能，synchronized会自动释放锁，而Lock一定要求程序员手动释放，并且必须在finally从语句中释放。
  大体上，使用synchronized关键字时，需要写的代码量更少，用户错误出现的可能性也会降低，因此通常只有再解决特殊问题时，才显示的使用Lock对象，例如synchronized关键字不能尝试着获取锁企且最终获取锁会失败，或者尝试着获取锁一段时间，然后放弃它。
  使用Lock时与try finally连用，使系统维护在正确的状态。

15.死锁
  产生原因：
  1.系统资源不足
  2.进程运行推进的顺序不合适
  3.资源分配不当，
  产生死锁的四个必要条件：
  1.互斥条件：一个资源每次只能被一个进程使用
  2.请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放，
  3.不剥夺条件：进程已获得的资源，在未使用完之前，不能强行剥夺
  4.循环等待条件：若干进程之间形成一种头尾相接的循环等待资源关系。
  合理避免四个必要条件之一就能避免死锁。

16.什么是线程池，如何使用
  线程池是一种多线程处理形式，处理过程中将任务添加到队列，然后在创建线程后自动启动这些任务。线程池都是后台线程。
  Java通过Executors提供四种线程池，分别为：
  New CachedThreadPool创建一个可缓存线程池，如果线程池超过处理需求，可灵活回收线程，若无可回收，则新建线程

  New FixedThreadPool创建一个定长线程池，可控制线程最大并发数，超过的线程会在队列中等待。

  New ScheduledThreadPool创建一个定长线程池，支持定时及周期性任务执行，
  New SingleThreadExecutor创建一个单线程化的线程池，他只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序执行，相当于数量为1的FixThreadPool,使用与长期存活的任务。

17.notify和notifyAll区别
  因为在技术上，可能会有多个任务在单个Car对象上处于wait状态，因此调用notify比只调用notifyAll要更安全。
  使用notify时，在众多等待同一个锁的任务中只有一个会被唤醒，因此如果你希望使用notify时，就必须保证被唤醒的是恰当的任务。
18.什么是死锁
  线程死锁是指由于两个或者多个线程先后持有对方所需要的资源，导致这些线程处于等待状态，无法前往执行。当线程进入对象的synchoronized代码块时，便占有了资源，直到它退出该代码块或者调用wait方法，才释放资源，在此期间，其他线程将不能进入该代码块，当线程相互持有对方所需要的资源时，会互相等待对方释放资源，如果线程都不主动释放所占有的资源，将产生死锁，
  产生死锁必要条件：
  1.互斥条件：进程对于所分配到的资源具有排他行，即一个资源只能被一个进程占有，直到被该进程释放
  2.请求和保持条件，指进程已经保持至少一个资源，但又提出了新的资源请求，而该资源已经被其它进程占有，此时请求进程阻塞，但又对自己已获得的其它资源保持不放；
  3.不剥夺条件：指进程已获得的资源，在未使用完之前，不能被剥夺，只能在使用完时由自己释放；
  4.环路等待条件：指在发生死锁时，必然存在一个进程----资源的环形链。

19.Android虚拟机与编译器的变迁
  虚拟机变迁：DavilkDavillk/ARTART
  编译器变迁:JITJIT/AOTAOTAOT/JIT
  Dalvik虚拟机：负责解释dex文件为机器码，每次执行代码，都需要Dalvik将dex代码翻译为微处理器指令，然后交给系统处理，这样效率不高。
  JIT:当APP运行时，每当遇到一个新类，JIT编译器就会对这个类进行编译，经过编译后的代码，会被优化成相当精简的原生型指令码，这样在下次执行到相同逻辑的时候，速度就会更快。
  ART虚拟机：与Dalvik不同，在ART环境中，应用在第一次安装的时候，字节码就会预先编译成机器码，使其成为真正的本地应用。使用时，会消耗更多的存储空间，但消耗空间的增幅通常不会超过应用代码大小的20%。由于有转码的过程，所以应用安装时间会延长。
  AOT:安装时编译。
  使用JIT编译器时，App优缺点
  优点：安装迅速、安装时所需容量小；
  缺点：使用了jit，在运行时编译，导致电量消耗快，jit本身也有开销。
  使用AOT编译器的时候，App优缺点:
  优点:启动快，运行不卡顿，因为直接执行的机器码，电量消耗少，没有了jit
  缺点：安装慢，因为安装的时候需要将.dex编译成本地机器码，
      需要更大的安装空间，因为将.dex编译成机器码之后，需要存储起来。